写了点关于新架构的思考，看看就好，具体的还是语音说。

# NekoStack (NS)

代表一个属于 wakame 的 ItemStack。也就是这个 ItemStack 可以被 wakame 识别。
只要是 NS(NekoStack)，那么其就一定有完整的 `wakame` NBT 数据，也就是拥有完整的：

- 根数据（id, seed, variant, ...)
- 核孔 (cell)
- 元数据 (meta)

NS 又分为 PNS(PlayNekoStack) 和 SNS(ShowNekoStack)。

一个 NS 是 PNS 还是 SNS，只看一个特定的 NBT 标签：`Byte('show')`.

该标签位于 `wakame` 之下。

只要该标签存在，无论其数值，那么将直接视为 SNS。
相反，如果该标签不存在，那么就是 PNS。
不存在“两者皆是”，也不存在“两者皆非”。

# PlayNekoStack (PNS)

代表一个玩家直接使用的 ItemStack。例如在地上，在箱子里，在玩家身上。

这一点跟原来的 NekoStack 定义是一致的。

# ShowNekoStack (SNS)

代表一个仅用于展示的 ItemStack，永远不会被玩家获得和使用。
一般出现在箱子 GUI 里（也就是“虚拟 Inventory”，或者“虚拟容器”）。

为什么会有 SNS？PNS 不够用吗？
回答：确实不够用。

某些情况下我们需要让物品在特定情况下，显示出不同的信息（不同的 name 和 lore）。

例如，当玩家把物品放入重铸界面里时，物品可能需要显示出更少/更多的信息。
具体的说，在重铸界面，当玩家操作核孔时，我们希望此时物品 lore 中的核孔会显示出各自的编号。
想象一下如果核孔没有任何编号，那么我们如何设计UI的操作流程，以便让玩家区分多个不同的**空**核孔？

这还只是使用场景之一，除此之外还有许多其他可能的场景。

这些场景都要求我们设计一套不同于现有的生成 name 和 lore 的架构，毕竟在现有的发包架构是不太容易满足上述场景的要求的。

下面是一些其他的可能会用到 SNS 的场景。

SNS 可能会显示更少的信息，例如：

- 不显示任何 lore，以强调物品的种类，而忽略物品具体的信息
- 物品名字不再根据稀有度而变色，而是游戏里最普通的默认白色

SNS 可能会显示更多的信息，例如：

- 揭露由于诅咒被隐藏的核孔
- 将物品提供的属性数值，显示为最终实际的数值（经过玩家身上所有修饰符的计算后）
- 每个核孔前面显示编号，以方便理解重铸界面的里对应的核孔信息

# 关于 Name 和 Lore

创建出来的 PNS 本身没有任何 name 和 lore，
因为设计上，其 name 和 lore 将会在发包阶段生成和填充。

那创建出来的 SNS 是怎么样的？
SNS 的 name/lore 不像 PNS，并不只有一种格式。
SNS 的 name/lore 需要根据不同的情况，来生成不同的内容。

那 SNS 也基于发包可行吗？
不大行。
因为目前的发包架构能获取到的信息仅仅是 ItemStack 本身，并没有任何其他的上下文可供参考。

因此不像 PNS，SNS 的 name/lore 不应该在发包阶段修改，而应该直接写入 NBT。
这也就意味着，SNS 需要的是一整套全新的 name/lore 的生成/操作机制。

想象一下，当你想把 NS 显示在虚拟容器里的时候，你想修改它的 name/lore，最好的办法是什么？
当然是**直接**修改成需要的样子，而不是修改上面的 NBT 然后让发包系统**间接**应用更改。

但是直接用 `ItemMeta.displayName(...)` 和 `ItemMeta.lore(...)` 又太原始了，它不够抽象，不够简洁，甚至容易出问题。
所以我们需要抽象，来把原本原始的操作给规范化，使其能够像 `BinaryItemMeta` 那样优雅。

这就是 SNS 存在的目的。
